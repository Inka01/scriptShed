#!/usr/bin/env ruby

require 'thread'
require 'bio'


# option checking
require 'optparse'

# Parse cmd line options
USAGE = "Usage: compare_condition_workflow.rb  [-n INT] [-i INT] -c CONTIGS [-t THREADS] [FILES]"
options = {
  :number => 0,
  :contigs => "",
  :iterations => 20,
}

OptionParser.new do |opts|
  opts.banner = USAGE

  opts.on("-n", "--number INT", "Number of reads to be subsampled. Default is 100 less than the smallest number found") do |v|
    window = v.to_i
    unless window > 0
      raise Exception, "Unexpected window size specified: #{v} - it must be greater than 0 bases long!"
    end
    options[:number] = window
  end
  
  opts.on("-i", "--iterations INT", "The number of iterations to perform subsampling. Default: 20") do |v|
    iterations = v.to_i
    unless iterations > 0
      raise Exception, "The number of iterations must be at least 1"
    end
    options[:iterations] = iterations
  end

  opts.on("-c", "--contigs FILE", "Location of the contigs generated by the joint assembly") do |c|
    unless File.readable?(c)
      raise Exception, "The contigs file is not readable"
    end
    options[:contigs] = c
  end
  
end.parse!


# initialize threads
thread_array = []
sm_number_array = []

# calculate the smallest number of reads
ARGV.length.times do |i|
  thread_array[i] = Thread.new {
    current_file = ARGV[i]
    current_count = 0
    Bio::FlatFile.auto(current_file).each do |record|
      current_count += 1
    end
    sm_number_array[i] = current_count
  }
end

thread_array.each {|t| t.join}

smallest_number = sm_number_array.min

# subsample the reads
#

# get the smallest number then minus 100 from it
subsample_level = smallest_number - 100

ARGV.length.times do |i|
  thread_array[i] = Thread.new {
    #make a tmp directory for this thread
    tmp_dir_name = File.basename(ARGV[i], File.extname(ARGV[i]))
    Dir.mkdir(tmp_dir_name)
    Dir.chdir(tmp_dir_name)
    options[:iterations].times do |j|
      tmp_prefix = "#{ARGV[i]}.thread.#{i}.iter.#{j}"
      # sample the reads
      tmp_file = "#{tmp_prefix}.fasta"
      `fastq_sample -n #{subsample_level} -o #{tmp_file} #{ARGV[i]}`
      # run BWA
      tmp_sam_file = "#{tmp_prefix}.sam"
      `makeSam.py -1 #{tmp_file} -l -s #{tmp_sam_file} -d #{options[:contigs]}`
      # turn into a bamfile
      `sam2bam #{tmp_sam_file}`
      # calculate coverage
      tmp_bam_file = "#{tmp_prefix}.bam"
      this_iter_table = "#{tmp_prefix}.out"
      `samtools depth #{tmp_bam_file} | perl compute_coverage_vec.pl >#{this_iter_table}`
      # remove the tmp files
      File.delete(tmp_sam_file, tmp_bam_file)
    end
  }
end

thread_array.each {|t| t.join}


# get average and standard error for all tables



