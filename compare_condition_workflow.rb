#!/usr/bin/env ruby

require 'thread'
require 'bio'
require 'bio-samtools'
require 'csv'
require 'optparse'

def calc_coverage(contigs, bam_file)

  # create a csv file to hold the data
  out_file = CSV.open(out_file_name, "wb")

  bam = Bio::DB::Sam.new(:bam => ARGV[0], :fasta => ARGV[1])
  bam.open
  contigs.each do |seq_name, seq_len|
    coverage = bam.chromosome_coverage(seq_name, 0, seq_len)
    coverage.unshift(seq_name)
    out_file << coverage
  end
end

def parse_options
  # Parse cmd line options
  USAGE = "Usage: compare_condition_workflow.rb  [-n INT] [-i INT] [-m INT] [-t THREADS] -c CONTIGS  FILES"
  options = {
    :number => 0,
    :contigs => "",
    :iterations => 20,
    :min_length => 1000
  }

  OptionParser.new do |opts|
    opts.banner = USAGE

    opts.on("-n", "--number INT", "Number of reads to be subsampled. Default is 100 less than the smallest number found") do |v|
      window = v.to_i
      unless window > 0
        raise Exception, "Unexpected window size specified: #{v} - it must be greater than 0 bases long!"
      end
      options[:number] = window
    end
    
    opts.on("-i", "--iterations INT", "The number of iterations to perform subsampling. Default: 20") do |v|
      iterations = v.to_i
      unless iterations > 0
        raise Exception, "The number of iterations must be at least 1"
      end
      options[:iterations] = iterations
    end

    opts.on("-c", "--contigs FILE", "Location of the contigs generated by the joint assembly") do |c|
      unless File.readable?(c)
        raise Exception, "The contigs file is not readable"
      end
      options[:contigs] = File.expand_path(c)
    end
    
    opts.on("-m", "--min-length INT", "The minimum length of the contigs for processing. Default: 1000") do |m|
      unless m.to_i > 0
        raise Exception, "The minimum contig length must be above 0"
      end
      options[:min_length] = m.to_i
    end
  end.parse!

  return options
end

options = parse_options


puts "Mapping from #{ARGV.length} files"
# initialize threads
thread_array = []
sm_number_array = []
output_mutex = Mutex.new
# calculate the smallest number of reads
ARGV.length.times do |i|
  thread_array[i] = Thread.new {
    current_file = ARGV[i]
    output_mutex.synchronize {
      puts "creating thread #{i} for file #{current_file}"
    }
    current_count = 0
    Bio::FlatFile.auto(current_file).each do |record|
      current_count += 1
    end
    sm_number_array[i] = current_count
  }
end

thread_array.each {|t| t.join}

smallest_number = sm_number_array.min

# subsample the reads
#
sm_number_array.each{|i|puts i}
# get the smallest number then minus 100 from it
subsample_level = smallest_number - 100
if subsample_level < 1
    raise Exception, "the number to sample is less than 1"
end

puts "Subsampling #{subsample_level} reads from all files"
puts "Creating BWA index"
`bwa index -a is #{options[:contigs]}`
ARGV.length.times do |i|
  thread_array[i] = Thread.new {
    #make a tmp directory for this thread
    tmp_dir_name = File.basename(ARGV[i], File.extname(ARGV[i]))
    Dir.mkdir(tmp_dir_name)
    output_mutex.synchronize {
      puts "made tmp directory #{tmp_dir_name}"
    }
    options[:iterations].times do |j|
      tmp_prefix = "#{ARGV[i]}.thread.#{i}.iter.#{j}"
      # sample the reads
      tmp_file = "#{tmp_prefix}.fasta"
      `fastq_sample -n #{subsample_level} -o #{tmp_dir_name}/#{tmp_file} #{ARGV[i]}`
      # run BWA
      tmp_sam_file = "#{tmp_prefix}.sam"
      `bwa bwasw #{options[:contigs]} #{tmp_dir_name}/#{tmp_file} >#{tmp_dir_name}/#{tmp_sam_file}`
      #`makeSam.py -1 #{tmp_dir_name}/#{tmp_file} -L -s #{tmp_dir_name}/#{tmp_sam_file} -d #{options[:contigs]}`
      # turn into a bamfile
      `sam2bam #{tmp_dir_name}/#{tmp_sam_file}`
      # calculate coverage
      tmp_bam_file = "#{tmp_prefix}.bam"
      this_iter_table = "#{tmp_prefix}.out"
      #`samtools depth #{tmp_dir_name}/#{tmp_bam_file} | perl compute_coverage_vec.pl >#{tmp_dir_name}/#{this_iter_table}`
      # remove the tmp files
      #File.delete(tmp_sam_file, tmp_bam_file)
    end
  }
end

thread_array.each {|t| t.join}


# get average and standard error for all tables



