#!/usr/bin/env ruby 

require 'bio'
require 'optparse'
require 'bio-logger'
require 'subcommand'

class App
  PROGRAM_NAME = "esomTools"
  
  attr_reader :options

  def initialize(arguments, stdin)
    @arguments = arguments
    @stdin = stdin
    
    # Set defaults
    @options = Hash.new
    @options[:verbose] = false
    @options[:quiet] = false
    # TO DO - add additional defaults
  end

  # Parse options, check arguments, then process the command
  def run
        
    if parsed_options?
      
      process_command
    end
      
  end
  
  protected
  
    def parsed_options?
      
      # Specify options
      opts = OptionParser.new
      opts.banner = "Usage: #{PROGRAM_NAME} [options]"
      opts.parse!(@arguments) rescue return false
      
      process_options
      unless arguments_valid?
        opts.help
      end
      true      
    end

    # Performs post-parse processing on options
    def process_options
      if @options.has_key?(:rm_class)
          @options[:rmcls] = true
      end
    end
    
    def output_options
      puts "Options:\
"
      
      @options.marshal_dump.each do |name, val|        
        puts "  #{name} = #{val}"
      end
    end

    # True if required arguments were provided
    def arguments_valid?
      return false if (@options[:partition_class] and @options[:rmcls])

      if @options[:rmcls]
        return false unless (@options[:cls_file] and @options[:lrn_file])
      elsif @options[:partition_class]
        return false unless (@options[:cls_file] and @options[:name_file] and @options[:fasta_file])
      end
      true
    end
    
    def process_command
    end


    def process_standard_input
      input = @stdin.read      
      # TO DO - process input
      
      # [Optional]
      # @stdin.each do |line| 
      #  # TO DO - process each line
      #end
    end

end #App

# not to be confused with Partition below
# this will simply remove the specified class
# from the lrn file
class RemoveCls

  def initialize(cls_file, lrn_file)
    @cls = cls_file
    @lrn = lrn_file
    # a lookup of the class(es) that we want to remove
    @classes = Hash.new
    # window to class hash map
    @windows = Hash.new
  end

  def populate_windows(line)
    a = line.split(/\t/)
    @windows[a[0]] = a[1]
    #@classes[a[1]] = true
  end

  def read_cls
    f = File.open(@cls)
    f.each do |line|
      line.chomp!
      next if line =~ /%/
      self.populate_windows(line)
    end
  end
  
  def read_lrn
    f = File.open(@lrn)
    f.each do |line|
      line.chomp!
      next if line =~ /%/
      l = line.split(/\t/)
      unless self.check_class(l[0])
        puts line
      end
    end
  end

  def check_class(window)
    @classes.has_key?(@windows[window])
  end

  def add_class(c)
    @classes[c] = true
  end

end #RemoveCls

# given a ESOM .cls file and a fasta file
# partition all contigs from a class into a
# separate file
class Partition
  
  def initialize(cls_file, name_file, fasta_file)
    @cls = cls_file
    @name = name_file
    @fasta = fasta_file
    @windows = Hash.new
    @contigs = Hash.new
    @classes = Hash.new{|h,k| h[k] = Array.new}
  end

  # the cls file contains lines of: window\tclass
  def populate_windows(line)
    a = line.split(/\t/)
    # this window is a member of this class
    @windows[a[0]] = a[1]
    # associate the window with the class
    @classes[a[1]] << a[0]
  end

  def read_cls
    f = File.open(@cls)
    f.each do |line|
      line.chomp!
      next if line =~ /%/
      self.populate_windows(line)
    end
  end
  
  # take a contig window name and 
  # convert it back to its original form
  def fix_contig_name(name)
    name.gsub!(/_leftover.*/,'')
    if name =~ /(.*)_\d+/
      return $1
    else
      return name
    end
  end

  def read_names
    f = File.open(@name)
    contig_classes = Hash.new
    
    f.each do |line|
      line.chomp!
      next if line =~ /%/
      a = line.split(/\t/)
      
      if @windows.has_key?(a[0])
        name = self.fix_contig_name(a[1])
        #@contigs[name] = @windows[a[0]]
        
        if @contigs.has_key?(name)
          # if the classes don't match assign the contig
          # to the class of the beast
          # but first take into account that some windows may have been missed - class '0'
          # in which case we should do nothing
          unless (@windows[a[0]] == @contigs[name]) ^ contig_classes[name]
            if @contigs[name] == '0'
              @contigs[name] = @windows[a[0]]
            elsif @windows[a[0]] != '0'
              $stderr.puts "contig: #{name} is binned in multiple classes! (#{@windows[a[0]]} #{ @contigs[name]})"
              @contigs[name] = "666"
              contig_classes[name] = true
            end
          end
        
        else
          # associate the class of the first window to the contig
          @contigs[name] = @windows[a[0]]
        end
      end
    end
  end

  def extract_class(class_number, out_stream)
    h = @contigs.select{|k,v| v == class_number}
    ex = Extractor.new(h, false, out_stream)
    ex.extract(@fasta)
  end

  def partition_all_classes
    @classes.each do |k,v|
      prefix = File.basename(@cls, ".cls")
      out = self.open_class_file(prefix, k) #File.open("#{prefix}.#{k}.fa", 'w')
      self.extract_class(k,out)
      out.close
    end
    
    # extract the contigs mapped in two classes
    prefix = File.basename(@cls, ".cls")
    out = self.open_class_file(prefix, "666") #File.open("#{prefix}.#{k}.fa", 'w')
    self.extract_class("666",out)
    out.close
  end

  def open_class_file(prefix, class_name)
    out = File.open("#{prefix}.#{class_name}.fa", 'w')
    return out
  end

  def partition
    self.read_cls
    self.read_names
    self.partition_all_classes
  end

end #Partition

# read a fasta file (or many) and extract reads
# that match a given list
class Extractor
  
  def initialize(wanted_headers, invert, out)
    @headers = wanted_headers
    @invert = invert
    @out_stream = out
  end
  
  def extract(infile)
    input_file = Bio::FlatFile.open(infile)
    input_file.each do |entry|
      if @headers.has_key?(entry.definition)
        if not @invert
          @out_stream.puts(entry)
        end
 
      elsif @invert
        @out.puts entry
      #else
      #  print "#{entry.definition}\n"
      end
    end
  end

end #Extractor

if __FILE__ == $0 #needs to be removed if this script is distributed as part of a rubygem
  include Subcommands
  SCRIPT_NAME = File.basename(__FILE__); LOG_NAME = SCRIPT_NAME.gsub('.rb','')

  VERSION = "0.1.1"
  # Parse command line options into the options hash
  options = {
    :logger => 'stderr',
  }

  global_options do |opts|
    opts.banner = " Usage: #{SCRIPT_NAME} [options] <subcommand> <arguments>\n A number of utilities for working with ESOM\n\n"
    opts.on('-v', '--inverse', "inverse the previous operations") { options[:inverse] = true }
    # logger options
    opts.on("-q", "--quiet", "Run quietly, set logging to ERROR level [default INFO]") {Bio::Log::CLI.trace('error')}
    opts.on("--logger filename",String,"Log to file [default #{options[:logger]}]") { |name| options[:logger] = name}
    opts.on("--trace options",String,"Set log level [default INFO]. e.g. '--trace debug' to set logging level to DEBUG"){|s| Bio::Log::CLI.trace(s)}

  end
  add_help_option
  command :partition do |opts|
    opts.banner = "partition -c <file.cls> -f <file.fa> -n <file.names>"
    opts.description = "Given a particular class list, will segregate all contigs from a class into separate fasta files"
    opts.on('-c', '--class-file [FILE]', "name of the class file") {|f| options[:cls_file] = f}
    opts.on('-n', '--name-file [FILE]', "name of the names file") {|f| options[:name_file] = f }
    opts.on('-f', '--fasta-file [FILE]', "name of the fasta file") {|f| options[:fasta_file] = f }    
  end

  command :remove do |opts|
    opts.banner = "remove -r <NUM> -c <file.cls> -l <file.lrn> "
    opts.description = "Delete all the windows of a class from an lrn file"
    opts.on('-r', '--remove-class NUM', "An integer value for the class that needs to be removed" ) {|v| options[:rm_class] = v.to_i}
    opts.on('-l', '--lrn-file [FILE]', "name of the lrn file") {|f| options[:lrn_file] = f}
    opts.on('-c', '--class-file [FILE]', "name of the class file") {|f| options[:cls_file] = f}
  end


  Bio::Log::CLI.logger(options[:logger])
  log = Bio::Log::LoggerPlus.new(LOG_NAME)
  Bio::Log::CLI.configure(LOG_NAME)
  
  cmd = opt_parse()
  case cmd
  when "partition"
    log.info "Partitioning classes"
    if options.has_key?(:cls_file) & options.has_key?(:name_file) & options.has_key?(:fasta_file)
      p = Partition.new(options[:cls_file], options[:name_file], options[:fasta_file])
      p.partition
    else
      log.error "please specify -c -n & -f on the command line"
      exit 1; 
    end
  when "remove"
    log.info "removing class"
    if options.has_key?(:cls_file) & options.has_key?(:lrn_file) & options.has_key?(:rm_class)
      r = RemoveCls.new(options[:cls_file], options[:lrn_file])
      r.add_class(options[:rm_class])
      r.read_cls
      r.read_lrn
    else
      log.error "please specify -c & -l on the command line"
      exit 1;
    end
  else
    $stderr.puts "unknown command: #{cmd}"
    exit 1
  end
  log.info "Done!"
end #end if running as a script
